"use strict";
/// <reference types="../index" />
/// <reference types="../typings/chai" />
/// <reference types="../typings/truffle" />
var utils_1 = require("./utils");
module.exports = function (chai, utils) {
    var Assertion = chai.Assertion;
    var flag = utils.flag;
    var property = function (name, assertFn) {
        Assertion.addProperty(name, assertFn);
    };
    var method = function (name, assertFn) {
        Assertion.addMethod(name, assertFn);
    };
    method("emitEvent", function (expectedEventName, message) {
        setMessageIfProvided(this, message);
        if (utils_1.isNil(expectedEventName)) {
            return assertHasEventEmittedWithAssertion(this, message);
        }
        assertIsTransactionResponse(this._obj, message);
        var obj = this._obj;
        var matchedEventLogIndexList = obj.logs
            .filter(function (log) { return !utils_1.isNil(log.event) && log.event === expectedEventName; })
            .map(function (log) { return log.logIndex; });
        var hasMatchedEvent = matchedEventLogIndexList.length !== 0;
        this.assert(hasMatchedEvent, "expected transaction to emit event '" + expectedEventName + "', but was not emitted", "expected transaction not to emit event '" + expectedEventName + "', but was emitted");
        setEmitEventLogPositionList(this, matchedEventLogIndexList);
        updateNegatedBeforeAssertEmitEvent(this);
        return this;
    });
    var assertHasEventEmittedWithAssertion = function (assertion, message) {
        assertIsTransactionResponse(assertion._obj, message);
        var obj = assertion._obj;
        var logWithEventFound = obj.logs.find(function (log) { return !utils_1.isNil(log.event); });
        var hasEventEmitted = !!logWithEventFound;
        var eventEmitted = hasEventEmitted && logWithEventFound.event;
        assertion.assert(hasEventEmitted, "expected transaction to emit event, but none was emitted", "expected transaction not to emit event, but event '" + eventEmitted + "' was emitted");
        return assertion;
    };
    method("emitEventAt", function (expectedEventName, position, message) {
        setMessageIfProvided(this, message);
        assertIsTransactionResponse(this._obj, message);
        var obj = this._obj;
        var objLogSize = obj.logs.length;
        var positionOutOfLogsSize = position > objLogSize - 1;
        if (positionOutOfLogsSize) {
            failAssertion(this, "expected transaction to emit event '" + expectedEventName + "' at position " + position + ", but only " + objLogSize + " event(s) was emitted");
            return this;
        }
        var eventAtTargetPosition = obj.logs[position].event;
        var hasTargetEventEmittedAtPosition = eventAtTargetPosition === expectedEventName;
        this.assert(hasTargetEventEmittedAtPosition, "expected transaction to emit event '" + expectedEventName + "' at position " + position + ", but '" + eventAtTargetPosition + "' was emitted", "expected transaction not to emit event '" + expectedEventName + "' at position " + position + ", but was emitted", expectedEventName, eventAtTargetPosition);
        setEmitEventLogPositionList(this, [position]);
        updateNegatedBeforeAssertEmitEvent(this);
        return this;
    });
    method("emitEventWithArgs", function (expectedEventName, assertArgsFn, message) {
        setMessageIfProvided(this, message);
        assertIsTransactionResponse(this._obj, message);
        var obj = this._obj;
        var matchedEventLogs = obj.logs.filter(function (log) { return !utils_1.isNil(log) && log.event === expectedEventName; });
        var hasMatchedEventLogs = matchedEventLogs.length !== 0;
        if (!hasMatchedEventLogs) {
            failAssertion(this, "expected transaction to emit event '" + expectedEventName + "' with matching argument(s), but was not emitted");
            return this;
        }
        var errorMessagePrefix = "expected transaction to emit event '" + expectedEventName + "' with matching argument(s)";
        var negatedErrorMessage = "expected transaction not to emit event '" + expectedEventName + "' with matching argument(s), but was emitted";
        assertEventArgsFromMatchedEventLogsWithAssertion(this, matchedEventLogs, assertArgsFn, errorMessagePrefix, negatedErrorMessage);
        return this;
    });
    method("emitEventWithArgsAt", function (expectedEventName, assertArgsFn, position, message) {
        setMessageIfProvided(this, message);
        assertIsTransactionResponse(this._obj, message);
        var obj = this._obj;
        var objLogSize = obj.logs.length;
        var isPositionOutOfLogsSize = position > obj.logs.length - 1;
        if (isPositionOutOfLogsSize) {
            failAssertion(this, "expected transaction to emit event '" + expectedEventName + "' at position " + position + ", but only " + objLogSize + " event(s) are emitted");
            return this;
        }
        var targetEventLog = obj.logs[position];
        if (targetEventLog.event !== expectedEventName) {
            failAssertion(this, "expected transaction to emit event '" + expectedEventName + "' at position " + position + " with matching argument(s), but was not emitted");
            return this;
        }
        var errorMessagePrefix = "expected transaction to emit event '" + expectedEventName + "' at position " + position + " with matching argument(s)";
        var negatedErrorMessage = "expected transaction not to emit event '" + expectedEventName + "' at position " + position + " with matching argument(s), but was emitted";
        assertEventArgsFromMatchedEventLogsWithAssertion(this, [targetEventLog], assertArgsFn, errorMessagePrefix, negatedErrorMessage);
        return this;
    });
    method("eventLength", eventLengthAssertFn);
    method("eventLengthOf", eventLengthAssertFn);
    function eventLengthAssertFn(expectedLength, message) {
        setMessageIfProvided(this, message);
        assertIsTransactionResponse(this._obj, message);
        var actualEventLogLength = this._obj.logs
            .length;
        this.assert(actualEventLogLength === expectedLength, "expected transaction to emit " + expectedLength + " event log(s), but " + actualEventLogLength + " was emitted", "expected transaction not to emit " + expectedLength + " event log(s)", expectedLength, actualEventLogLength);
        return this;
    }
    var assertIsTransactionResponse = function (value, message) {
        var assertion = new Assertion(value);
        setMessageIfProvided(assertion, message);
        assertion.is.transactionResponse;
    };
    method("evmFail", function (expectedErrorMessage, message) {
        var _this = this;
        setMessageIfProvided(this, message);
        assertIsPromiseLike(this._obj);
        var obj = this._obj;
        var derivedPromise = obj.then(function (result) {
            // Promise resolves to transaction response, if the assertion expect to fail,
            // then it should fail.
            var failMessage = utils_1.isNil(expectedErrorMessage)
                ? "expected transaction to fail in EVM, but it succeeded"
                : "expected transaction to fail in EVM because of '" + expectedErrorMessage + "', but it succeeded";
            failAssertion(_this, failMessage, {
                actual: result,
            });
            assertIsTransactionResponse(result, message);
        }, function (err) {
            if (utils_1.isNil(expectedErrorMessage)) {
                // Promise rejects to error, if the assertion expect not to fail,
                // then it should fail.
                failNegatedAssertion(_this, "expected transaction to succeed in EVM, but it failed", {
                    actual: err,
                });
            }
            else {
                var isErrorMessageMatch = err.message.indexOf(expectedErrorMessage) !== -1;
                _this.assert(isErrorMessageMatch, "expected transaction to fail in EVM because of '" + expectedErrorMessage + "', but it failed of another reason: " + err.message, "expected transaction not to fail in EVM because of '" + expectedErrorMessage + "', but it was", expectedErrorMessage, err.message);
            }
        });
        this.then = derivedPromise.then.bind(derivedPromise);
        return this;
    });
    method("evmInvalidOpcode", function (message) {
        return this.to.evmFail("invalid opcode", message);
    });
    method("evmOutOfGas", function (message) {
        return this.to.evmFail("out of gas", message);
    });
    method("evmRevert", function (message) {
        return this.to.evmFail("revert", message);
    });
    method("evmSuccess", function (message) {
        var _this = this;
        setMessageIfProvided(this, message);
        assertIsPromiseLike(this._obj, message);
        var obj = this._obj;
        var derivedPromise = obj.then(function (result) {
            // Promise resolves to transaction response, if the assertion expect not
            // to broadcast, then it should fail.
            failNegatedAssertion(_this, "expected transaction to fail in EVM, but it succeeded");
            assertIsTransactionResponse(result, message);
        }, function (err) {
            // Promise rejects to error, if the assertion expect to broadcast,
            // then it should fail.
            failAssertion(_this, "expected transaction to succeed in EVM, but it failed", {
                actual: err,
            });
        });
        this.then = derivedPromise.then.bind(derivedPromise);
        return this;
    });
    property("transactionResponse", function () {
        this.assert(isTransactionResponse(this._obj), "expected #{this} to be a Truffle TransactionResponse", "expected #{this} not to be a Truffle TransactionResponse");
        return this;
    });
    var TRANSACTION_RESPONSE_KEYS = ["tx", "receipt", "logs"];
    var isTransactionResponse = function (value) {
        if (typeof value !== "object") {
            return false;
        }
        if (utils_1.isNil(value)) {
            return false;
        }
        for (var _i = 0, TRANSACTION_RESPONSE_KEYS_1 = TRANSACTION_RESPONSE_KEYS; _i < TRANSACTION_RESPONSE_KEYS_1.length; _i++) {
            var key = TRANSACTION_RESPONSE_KEYS_1[_i];
            if (typeof value[key] === "undefined") {
                return false;
            }
        }
        return true;
    };
    method("withEventArgs", function (assertArgsFn) {
        if (!isEmitEventAsserted(this)) {
            throw new Error("to assert event arguments the assertion must be asserted with emitEvent() or emitEventAt() first. i.e. expect(...).to.emitEvent(...).withEventArgs(...)");
        }
        if (isNegatedBeforeAssertEmitEvent(this)) {
            throw new Error("expect(...).not.to.emitEvent(...).withEventArgs(...) pattern is not support. If you are asserting a transaction has emitted an event but not with the certain argument format, consider using expect(...).to.emitEvent(...).not.withEventArgs(...) instead");
        }
        var obj = this._obj;
        var eventLogPositionList = getEmitEventLogPositionList(this);
        var firstMatchedEventLogIndex = eventLogPositionList[0];
        var eventName = obj.logs[firstMatchedEventLogIndex].event;
        var matchedEventLogs = eventLogPositionList.map(function (position) { return obj.logs[position]; });
        var errorMessagePrefix = "expected transaction to emit event '" + eventName + "' with matching argument(s)";
        var negatedErrorMessage = "expected transaction to emit event '" + eventName + "' but not with matching argument(s), but argument(s) match";
        assertEventArgsFromMatchedEventLogsWithAssertion(this, matchedEventLogs, assertArgsFn, errorMessagePrefix, negatedErrorMessage);
        return this;
    });
    var assertEventArgsFromMatchedEventLogsWithAssertion = function (assertion, matchedEventLogs, assertArgsFn, errorMessagePrefix, negatedErrorMessage) {
        var hasMatchedEvent = false;
        var lastError;
        for (var _i = 0, matchedEventLogs_1 = matchedEventLogs; _i < matchedEventLogs_1.length; _i++) {
            var eventLog = matchedEventLogs_1[_i];
            try {
                if (assertArgsFn(eventLog.args)) {
                    hasMatchedEvent = true;
                    break;
                }
            }
            catch (err) {
                lastError = err;
            }
        }
        var errorMessage = errorMessagePrefix;
        var assertionValue = {};
        if (typeof lastError === "undefined") {
            errorMessage = errorMessage + ", but argument(s) do not match";
        }
        else {
            errorMessage = errorMessage + ", but argument(s) assert function got: '" + lastError.message + "'";
            if (lastError instanceof chai.AssertionError) {
                var assertionError = lastError;
                assertionValue.expected = assertionError.expected;
                assertionValue.actual = assertionError.actual;
            }
        }
        assertion.assert(hasMatchedEvent, errorMessage, negatedErrorMessage, assertionValue.expected, assertionValue.actual);
    };
    var assertIsPromiseLike = function (value, message) {
        var assertion = new Assertion(value);
        setMessageIfProvided(assertion, message);
        assertion.assert(typeof value.then !== "undefined", "expected #{this} to be a Promise", "expected #{this} not to be a Promise", "Promise", typeof value);
    };
    var failNegatedAssertion = function (assertion, message, value) {
        if (value === void 0) { value = {}; }
        assertion.assert(true, "", message, value.expected, value.actual);
    };
    var failAssertion = function (assertion, message, value) {
        if (value === void 0) { value = {}; }
        assertion.assert(false, message, "", value.expected, value.actual);
    };
    var isNegated = function (assertion) {
        return !utils_1.isNil(flag(assertion, "negate"));
    };
    var isNegatedBeforeAssertEmitEvent = function (assertion) {
        return !utils_1.isNil(flag(assertion, "truffleNegatedBeforeAssertEmitEvent"));
    };
    var isEmitEventAsserted = function (assertion) {
        return !utils_1.isNil(flag(assertion, "truffleEmitEventLogPositionList"));
    };
    var setEmitEventLogPositionList = function (assertion, positionList) {
        flag(assertion, "truffleEmitEventLogPositionList", positionList);
    };
    var setMessageIfProvided = function (assertion, message) {
        if (!utils_1.isNil(message)) {
            flag(assertion, "message", message);
        }
    };
    var updateNegatedBeforeAssertEmitEvent = function (assertion) {
        if (isNegated(assertion)) {
            return flag(assertion, "truffleNegatedBeforeAssertEmitEvent", true);
        }
    };
    var getEmitEventLogPositionList = function (assertion) {
        return flag(assertion, "truffleEmitEventLogPositionList");
    };
};
//# sourceMappingURL=chai-truffle.js.map